---
description: |
  数据库与数据建模规则（Data Rules）。
  用于约束关系型数据库的表结构设计、字段命名、约束策略、查询规范与演进方式。
---

# Data Rules（数据库设计与查询规范）

## 1. 适用范围

本规范适用于关系型数据库（MySQL / PostgreSQL / TiDB 等）中的：

- 表结构（DDL）设计
- 字段命名与类型选择
- 索引与约束策略
- 数据关系建模
- 查询 SQL 编写规范
- 数据演进（迁移 / 回填 / 兼容）

---

## 2. 强制规则（Must）

### 2.1 禁止使用外键（Foreign Key 禁用）

- **不允许创建外键约束**（`FOREIGN KEY`）。
- 关系一致性由：
  - 应用层逻辑
  - 数据校验任务（定时/离线）
  - 约定关联字段 + 索引
  来保证。

---

### 2.2 必须满足基础数据库范式（Normalization）

- 至少满足 **1NF / 2NF / 3NF** 的基本要求：
  - 1NF：字段原子性
  - 2NF：非主属性完全依赖主键
  - 3NF：非主属性不传递依赖非主属性
- 如因性能需要反范式（冗余）：
  - 必须说明冗余原因与一致性策略（见 2.5/5.3）。

---

### 2.3 字段命名规范：驼峰且不带下划线（camelCase）

- 所有列名使用 **lowerCamelCase**，禁止下划线（如：`createdAt`、`userUid`）。
- 推荐标准字段名：
  - `uid`：业务主键（见 2.4）
  - `tenantUid`：租户标识（见 2.7）
  - `createdAt` / `updatedAt` / `deletedAt`：时间字段（见 2.6）

---

### 2.4 必须使用独立的 uid（long）

- 每张业务表必须包含：`uid BIGINT`（等价 long）。
- `uid` 作为对外引用与业务关联主键。
- 如存在自增主键：
  - 仅限内部使用
  - 对外与关联仍以 `uid` 为准。

---

### 2.5 充分设计关系型数据库关系，适当使用冗余

- 必须显式建模实体关系（1:1 / 1:N / N:N）：
  - 通过 `xxxUid` 字段表达关联
  - 并按查询场景建立索引
- 允许适当冗余，但必须满足：
  - 明确“真实数据源”（source of truth）
  - 明确一致性策略（同步/异步/重算/校验）
  - 有回填与校验方案

---

### 2.6 软删除（Soft Delete 强制）

- 默认所有业务表启用软删除：`deletedAt`（nullable）
  - `deletedAt IS NULL` 表示未删除
- 删除操作默认执行软删除，不做物理删除（除非明确例外）
- 查询默认应过滤已删除数据：
  - 必须在 SQL/ORM 层统一约定（例如默认 scope）
- 若存在需要物理删除的表：
  - 必须在设计文档中注明原因与数据保留策略

---

### 2.7 多租户（Multi-tenant 强制）

- 如系统为多租户架构：
  - 所有核心业务表必须包含租户 UID(如tenantUid） ` BIGINT`
- 所有查询/写入必须显式携带 `租户 UID` 作为约束条件之一
- 唯一性约束与索引设计应考虑租户隔离：
  - 推荐组合唯一键：`租户 UID + bizKey`
  - 组合索引：`(租户 UID, xxx)` 用于常见查询路径

> 注：如确有跨租户共享表（字典表/公共配置表），必须在文档中标注并说明访问策略。

---

---

### 2.8 字段类型

- 枚举值必须使用byte类型存储


### 2.9 comment

- 表、索引、字段，都需要给出简明的中文备注

---

## 3. 查询 SQL 规则（Must）

### 3.1 禁止连表超过 3 张

- 单条查询 SQL 的 `JOIN` 表数量 **不得超过 3 张**（包含主表）。
- 超过 3 张的情况必须：
  - 拆分为多次查询（应用层聚合）
  - 或引入冗余/预计算表/物化视图（如允许）
  - 或调整查询模型（例如先查主键集合，再批量查明细）

> 目的：控制查询复杂度与性能风险，避免高耦合、难优化的查询。

---

### 3.2 查询多条数据必须分页

- 任何返回“列表/多条记录”的查询必须分页：
  - 禁止无边界全量查询
- 默认推荐：
  - **Keyset Pagination**（按稳定排序字段，如 `uid` / `createdAt`）
  - 如必须 offset/limit，也需明确最大 offset 风险与上限策略
- 分页必须明确：
  - 排序字段（稳定、可索引）
  - 页大小上限（建议在应用层强制）

---

### 3.3 查询 SQL 必须检查是否命中索引

- 对关键/线上路径查询，必须进行索引命中检查：
  - MySQL：`EXPLAIN` / `EXPLAIN ANALYZE`
  - Postgres：`EXPLAIN (ANALYZE, BUFFERS)`
- 必须关注：
  - 是否走到预期索引（key / index name）
  - 访问类型（避免全表扫描）
  - 估算行数与实际行数偏差（如可得）
- 如未命中索引：
  - 必须调整索引或重写 SQL
  - 或在文档中说明原因与风险控制（例如小表、低频离线任务）

---

## 4. 查询 SQL 建议（Recommended）

### 4.1 索引友好的查询写法

- 避免在索引列上做函数/表达式导致索引失效
- 避免隐式类型转换（保证入参类型一致）
- 避免 `SELECT *`（线上路径推荐显式列）
- 需要排序/分页时，排序字段应可索引且稳定

---

### 4.2 N+1 风险控制

- 列表查询后再逐条查明细属于高风险：
  - 推荐批量查询（IN / 批量接口）
  - 或通过冗余字段减少二次查询
- 但批量 IN 也应设上限（由应用层控制）

---

### 4.3 冗余与预计算

- 当查询需要多表聚合且 JOIN 超过限制时，优先考虑：
  - 适度冗余字段
  - 预计算表/宽表（如业务允许）
  - 异步任务回填/校验一致性

---

## 5. 数据演进与兼容（强制）

### 5.1 Schema 变更原则

- 任何 schema 变更必须可兼容与可回滚：
  - 新增列优先（nullable 或默认值）
  - 避免直接删除/重命名列（用“新增 → 回填 → 切换 → 清理”）
- 必须包含：
  - 迁移脚本
  - 回填脚本（如需要）
  - 回滚方案

---

### 5.2 软删除数据治理

- 软删除表需要明确：
  - 是否存在清理策略（TTL / 定时物理清理）
  - 清理任务的审计与保护（避免误删）
- 如存在合规要求（保留期），必须在文档中注明

---

### 5.3 冗余一致性策略（当存在冗余时必须写清）

- 冗余字段必须明确：
  - 真实数据源（source of truth）
  - 更新策略：
    - 同步写（事务内）
    - 异步修正（消息/任务）
    - 重算回填（离线）
  - 校验与修复机制：
    - 定时校验任务
    - 数据对账报表/告警

---

## 6. 关系建模建议（无外键前提）

- 1:N：在 N 侧保存 `xxxUid`，并为其建索引
- N:N：必须使用中间表（join table）
  - 包含 `aUid`、`bUid`（以及 `tenantUid` 如适用）
  - 推荐唯一约束（逻辑唯一）：`(tenantUid, aUid, bUid)` 或 `(aUid, bUid)`

---

## 7. Checklist（提交前必查）

### 7.1 设计检查

- [ ] 无任何外键（FOREIGN KEY）
- [ ] 满足 1NF/2NF/3NF（冗余有说明与一致性策略）
- [ ] 每表有 `uid BIGINT`
- [ ] 字段命名全部为 lowerCamelCase（无下划线）
- [ ] 启用软删除：`deletedAt`
- [ ] 多租户：核心表包含 `tenantUid`，并纳入索引/唯一性设计

### 7.2 查询检查

- [ ] 单条 SQL JOIN 不超过 3 张表
- [ ] 列表查询必须分页（有稳定排序字段）
- [ ] 关键查询已做 EXPLAIN 检查并命中预期索引
- [ ] 无明显 N+1 风险或已采取批量/冗余策略
