---

## 0. 总目标与适用范围

### 0.1 总目标

在编写代码时，以 **可维护的工程代码** 为唯一目标：

- **可读**：工程成员能在短时间内理解意图
- **可测**：核心逻辑可独立测试
- **可演进**：需求变化时影响范围可控
- **可审计**：行为变化可追溯、可复盘

### 0.2 适用范围

适用于任何语言、任何架构下的：

- 新功能开发
- 功能迭代
- Bug 修复
- 技术替换与重构

---

## 1. 设计原则（高层约束）

### 1.1 SOLID 与通用设计原则（强制）

- **SRP（单一职责）**
  一个模块 / 类 / 函数只能有一个主要变化原因

- **OCP（开闭原则）**
  在不过度抽象的前提下，新增能力优先通过扩展而非修改旧逻辑

- **LSP（里氏替换）**
  替换实现不得破坏调用方的既有假设

- **ISP（接口隔离）**
  接口应小而清晰，避免“万能接口”

- **DIP（依赖倒置）**
  核心逻辑依赖抽象，而非具体实现

> 约束：遵循设计原则，但禁止“为了架构而架构”。
> 抽象必须有明确的变化点支撑。

---

### 1.2 KISS / YAGNI（强制）

- **KISS**：优先选择最简单可行方案
- **YAGNI**：没有明确需求，不提前设计扩展点

---

## 2. 可维护性与规模控制（硬约束 · 强制）

> 本章用于**强制避免大文件 / 大函数**导致的不可维护问题。
> 所有阈值为跨语言通用上限；若团队/语言规范更严格，以更严格者为准。

---

### 2.1 大文件限制（File Size Limits）

#### 2.1.1 软上限（健康范围）
- 单文件 ≤ **250 行**（不含空行与纯注释）

#### 2.1.2 硬上限（强制）
- 单文件 **> 350 行**：必须拆分（不可仅解释）
- 单文件 **> 500 行**：禁止提交

#### 2.1.3 允许例外
仅限以下情况（必须显式标注）：
- 自动生成代码（generated）
- 纯数据结构 / Schema / 协议定义（schema-only）

#### 2.1.4 触发后的强制动作
- 按职责拆分为多个代码单元
- 明确每个单元的职责边界
- 不得通过“继续堆代码”解决问题

---

### 2.2 大函数限制（Function Size Limits）

#### 2.2.1 软上限（健康范围）
- 单函数 ≤ **30 行**

#### 2.2.2 硬上限（强制）
- 单函数 **> 50 行**：必须拆分
- 单函数 **> 80 行**：禁止提交

#### 2.2.3 拆分要求
- 按职责拆分（校验 / 决策 / I/O 不得混在一起）
- 不同抽象层级不得混写在同一函数
- 拆分出的核心逻辑必须可独立测试

---

### 2.3 大类 / 大模块限制

- 单类 / 单模块 **> 300 行**：必须拆分
- 对外暴露的 public API / 导出函数 **> 12 个**：必须重新划分职责

---

## 3. 职责拆分与依赖原则（架构 / 语言无关）

### 3.1 按职责拆分，而不是按技术类型堆叠（强制）

代码必须按其承担的**职责**进行逻辑隔离（不要求特定目录结构）：

- **业务规则（Business Rules）**
  核心业务决策、不变量

- **流程编排（Application Flow）**
  组织一次业务执行过程

- **边界抽象（Boundary / Contract）**
  与外部系统交互的契约

- **外部实现（Infrastructure / Integration）**
  数据库、网络、文件、第三方系统等 I/O

- **数据表达（Data Shape）**
  输入 / 输出结构、序列化、校验

- **通用支持（Shared Utilities）**
  业务无关的小型稳定工具

**禁止行为：**

> 禁止在同一代码单元中同时处理：
> 外部请求 / 事件 + 核心业务决策 + 数据持久化或网络 I/O

---

### 3.2 依赖方向必须向内收敛（强制）

- 核心业务规则不得依赖任何具体技术或 I/O
- 与外部交互必须通过抽象完成
- 外部实现可以依赖内部抽象，但不能反向污染业务规则

原则性表述：

> 业务规则不应感知技术细节，
> 技术实现应适配业务规则。

---

## 4. 复用与抽象（避免重复与过度设计）

### 4.1 复用规则（强制）

- 重复逻辑出现即需提取
- 跨多处复用时，必须形成独立模块并暴露清晰接口
- 复用代码必须：
  - 输入 / 输出清晰
  - 副作用显式
  - 易于测试

---

### 4.2 抽象引入门槛（强制）

引入抽象必须满足至少一项：

- 存在明确替换需求
- 存在明确扩展需求
- 为隔离外部依赖、提升可测试性

禁止抽象的信号：

- 只有一个实现且无变化点
- 抽象层只做参数转发
- 抽象增加理解成本但无实际收益

---

## 5. 可读性（强制）

### 5.1 命名

- 命名必须准确反映意图
- 避免泛化命名（data / info / process / handle 等）
- 布尔变量使用 is / has / can / should 前缀
- 函数命名体现“动作 + 对象”

---

### 5.2 控制流清晰

- 避免深层嵌套
- 优先使用 guard clause
- 分支条件必须清晰可读

---

### 5.3 注释与文档

- 注释解释“为什么”，而不是“做了什么”
- 复杂逻辑需说明：
  - 设计意图
  - 不变量
  - 边界条件

---

## 6. 副作用与错误处理（强制）

### 6.1 副作用显式化

- 任何产生副作用的行为必须显式表达
- 禁止在“看似无副作用”的函数中写数据或发请求
- 禁止隐藏全局状态读写

---

### 6.2 错误语义一致

- 错误处理策略必须清晰、一致
- 不允许吞错或静默失败（除非有明确降级策略）

---

## 7. 可测试性（强制前提）

### 7.1 核心逻辑可独立测试

- 核心业务逻辑不得直接依赖外部系统
- 外部依赖必须可替换（mock / stub）

---

### 7.2 测试要求

- 关键路径至少包含：
  - 正常流程测试
  - 边界 / 异常测试
- 测试命名应体现行为语义

---

## 8. 演进与变更控制

### 8.1 行为变化显式化

- 修改必须说明：
  - 哪些行为改变
  - 哪些行为保持不变

---

### 8.2 Bugfix 特别约束

- Bugfix 优先最小改动
- 不引入新抽象，除非原设计阻止修复

---

## 9. 最终自检清单（Checklist）

在提交代码前至少确认：

- [ ] 无超出硬上限的大文件 / 大函数
- [ ] 职责边界清晰，I/O 未渗透核心逻辑
- [ ] 命名准确，控制流清晰
- [ ] 重复逻辑已提取
- [ ] 核心逻辑可独立测试
- [ ] 错误处理语义一致
- [ ] 行为变化已显式说明

---
