
---
description: 用于在现有项目中以工程化、科学的方法实现一个新功能
---
---
details:  支持从多种信息来源理解需求，强制识别是否存在旧实现， 遵循“文档先行 → 测试先行 → 实现 → MVP 快速验证”的流程， 并在可控、可回滚的前提下自动推进。
---

## 一、User Input

```text
1. 加载以下提示词文档（按顺序，遵循 doc_loader.md 规则）：
   - ${old_base}
   - ${new_base}
   - ${git_rules}
   - ${codestyle}
   - ${data_rule}
   - ${constitution}（如存在，项目级基础规则）

2. 我将提供一个新功能需求以及需求信息来源，其信息来源可能包括：
   - 在线网站 / URL
   - 图片或截图
   - 文档（PRD / Markdown / PDF / Notion 等）
   - Figma URL 或设计稿

3. 请你严格按照本文档定义的流程，
   以科学、工程化的方式完成新功能实现任务：

   $ARGUMENTS
```

### 前置环境检查（强制）

- 遵循 `git_rules` 中的 Git 规则
- 确认输出目录 `./mydoc/{date}-{taskname}/` 可写，不存在则创建（若用户未提供，直接自动生成，不必询问）
- 按 doc_loader 规则检查所需 prompt 是否可读取，缺失时必须暂停并告知

## 二、总体目标与基本原则

### 目标

- 正确理解需求，而不是猜测需求
- 避免重复实现或隐式替换旧逻辑
- 以最小风险的方式引入新能力
- 确保每一步都有文档与验证依据

### 基本原则（强制）

```
- 不跳步
- 不脑补
- 不直接实现
- 所有结论必须可复盘
```

### OpenAPI 规范约束（强制）

**OpenAPI 规范是 API 接口定义的唯一真源（Single Source of Truth）**

* 所有 API 接口设计必须基于 OpenAPI 规范文件
* 在实现 API 接口前：
  * 必须首先查找并引用对应的 OpenAPI 规范文件
  * 若 OpenAPI 规范不存在，必须先创建或更新 OpenAPI 规范
  * 不得基于代码、文档或其他来源自行推断接口定义
* 在 framework.md 中设计接口时：
  * 必须标注对应的 OpenAPI 规范路径和操作 ID
  * 格式：`[OpenAPI: {file_path}#/{operationId}]`
* 若发现代码实现与 OpenAPI 规范不一致：
  * 以 OpenAPI 规范为准
  * 必须修正代码实现以符合 OpenAPI 规范
* 所有新增或修改的 API 接口：
  * 必须同步更新 OpenAPI 规范文件
  * 确保 OpenAPI 规范始终反映最新的接口定义

------

## 三、阶段一：读取信息来源 & 需求理解（禁止设计与实现）

### 3.1 信息来源识别

识别我提供的需求来源类型，并采用对应的理解策略：

- **在线网站 / URL**
  - 关注用户路径、可观察行为
  - 不假设后端或隐藏规则
- **图片 / 截图**
  - 明确 UI 元素、状态、信息层级
  - 交互行为必须标注为推断
- **文档**
  - 提取明确规则、输入输出、边界条件
  - 标注歧义、不一致或可能过期内容
- **Figma**
  - 理解设计意图与交互流
  - 明确设计 ≠ 技术实现

------

### 3.2 需求理解原则（强制）

```
- 只做理解，不做设计
- 明确区分：事实 / 推断 / 假设
- 不允许隐式前提
```

------

### 3.3 输出：需求理解模块（写入 framework.md）

```markdown
## 需求理解

### 1. 需求来源
- 来源类型：
- 内容摘要：

### 2. 已确认事实（Facts）
- ...

### 3. 推断的意图（Inferred Intent）
- ...（注明依据）

### 4. 假设（Assumptions）
- ...

### 5. 澄清点 / 未决问题（最多 5 个）
- ...

### 6. 功能边界
- 明确做什么
- 明确不做什么
```

> 若存在关键澄清点，必须先与我确认，不得进入下一阶段。

------

## 四、阶段二：现有实现识别（强制阶段）

### 4.1 阶段目标

- 判断系统中是否已经存在：
  - 相同功能
  - 相似能力
  - 可复用或可演进的旧实现
- 防止：
  - 重复造轮子
  - 无意中形成“隐式替换”

------

### 4.2 执行规则（强制）

```
- 不允许假设“这是全新功能”
- 不允许直接进入设计阶段
- 必须显式给出结论
```

------

### 4.3 执行内容

在代码库中主动检查：

- 是否存在：
  - 语义相近的模块 / 类 / 函数
  - 已通过配置或内部使用的类似能力
- 若发现相关实现：
  - 分析其覆盖范围与不足
- 若未发现：
  - 明确记录“未发现相关实现”

------

### 4.4 输出：现有实现识别模块（写入 framework.md）

```markdown
## 现有实现识别

### 1. 是否存在相关实现
- 是 / 否

### 2. 已发现的相关实现（如有）
- 位置（模块 / 文件）：
- 当前能力：
- 已知限制：

### 3. 复用或演进可能性
- 可直接复用
- 可扩展演进
- 不适合复用（原因）

### 4. 结论
- 新功能应：
  - 基于现有实现演进
  - 或作为独立模块新增
```

------

## 五、阶段三：功能设计与实现规划（文档先行）

### 5.1 设计约束（继承 new_base）

- 最小侵入
- 边界清晰
- 默认可配置、可回滚
- 明确 MVP 与演进路径

### 5.1.1 前端设计前置（如有前端需求）

若功能涉及前端页面或用户界面，必须先完成：

- **前端页面结构设计**：页面布局、组件结构、路由规划
- **交互流程设计**：用户操作路径、状态流转、反馈机制
- **数据流设计**：前端状态管理、API 调用时机、数据格式
- **UI/UX 设计确认**：设计稿、原型或明确的视觉规范

**强制规则：**
- 前端设计必须在后端接口设计之前或同步完成
- 前端设计必须纳入 MVP 范围（如适用）
- 不得在未完成前端设计的情况下直接开始前端实现

------

### 5.2 输出：新功能设计模块（写入 framework.md）

```markdown
## 新功能设计

### 1. 功能目标
- 要解决的问题
- 核心价值

### 2. 设计思路
- 模块划分
- 与现有系统的交互方式

### 3. 前端页面设计（如有前端需求）
- 页面结构与布局
- 交互流程与状态流转
- UI 组件与元素
- 数据流（用户输入 → 前端状态 → API 调用）
- 响应式设计考虑（如适用）
- 设计稿或原型参考（如有）

### 4. 接口与数据设计
- 对外接口
  - 必须基于 OpenAPI 规范：[OpenAPI: {file_path}#/{operationId}]
  - 若 OpenAPI 规范不存在，必须先创建
- 核心数据结构
  - 请求/响应结构必须与 OpenAPI 规范一致

### 5. 行为说明
- 正常流程
- 异常与边界场景

### 6. MVP 定义
- MVP 包含的能力
- 明确不包含的内容
- MVP 包含的前端页面范围（如有）

### 7. 后续演进方向
- 可扩展点
- 潜在优化方向
```

------

## 六、阶段四：测试用例设计（先于实现）

### 6.1 测试设计原则

- 测试是功能语义的可执行表达
- 测试用于约束实现，而不是事后补充
- MVP 测试必须覆盖核心成功路径

------

### 6.2 输出：测试设计模块（写入 framework.md 或 task.md）

```markdown
## 测试设计

### 1. 核心测试场景
- Given / When / Then

### 2. 边界与异常测试
- ...

### 3. 回归关注点
- ...
```

------

## 七、阶段五：任务拆解与 MVP 规划

### 7.1 MVP 任务识别（强制）

在拆解任务前，必须先明确：

- **MVP 核心任务集合**：构成最小可验证功能的任务列表
- **MVP 依赖关系**：哪些任务必须先完成才能实现 MVP
- **非 MVP 任务**：可在 MVP 验证后再实现的任务

------

### 7.2 Todo List（写入 task.md）

任务列表必须按优先级分组，格式如下：

```markdown
## 任务拆解

### MVP 核心任务（P0 - 必须优先完成）

#### 任务 1：[任务名称]
- **目的**：...
- **MVP 标识**：是
- **优先级**：P0
- **改动点**：...
- **依赖关系**：无 / 任务 X
- **验收标准**：...
- **对应测试**：...
- **状态**：TODO

### MVP 相关任务（P1 - MVP 验证后可继续）

#### 任务 2：[任务名称]
- **目的**：...
- **MVP 标识**：是
- **优先级**：P1
- **改动点**：...
- **依赖关系**：任务 1
- **验收标准**：...
- **对应测试**：...
- **状态**：TODO

### 后续任务（P2 - MVP 完成后实现）

#### 任务 3：[任务名称]
- **目的**：...
- **MVP 标识**：否
- **优先级**：P2
- **改动点**：...
- **依赖关系**：任务 2
- **验收标准**：...
- **对应测试**：...
- **状态**：TODO
```

**强制规则：**
- 所有 P0 任务必须在 P1/P2 任务之前完成
- 任务列表必须按优先级分组并排序（P0 → P1 → P2）
- 前端页面相关任务（如有）必须明确标注优先级和依赖关系
- 不允许在 P0 任务未完成时开始 P1/P2 任务

------

### 7.3 MVP 验证定义（强制）

- MVP 必须：
  - 验证新功能是否可用
  - 验证未破坏既有行为
- 明确验证步骤与成功标准
- **MVP 任务完成标准**：所有 P0 任务完成 + 对应测试通过

------

## 八、阶段六：实现 & MVP 快速验证

### 8.1 实现规则

- 严格遵循 `new_base` 与 `codestyle`
- 不得绕过测试设计直接实现
- 不得引入未记录的新依赖或行为变化
- * 涉及到数据库操作必须严格遵守 `data_rule`

------

### 8.2 推进机制（强制 MVP 优先）

```
1. 优先实现 MVP（P0 任务）
   - 严格按照 P0 → P1 → P2 的优先级顺序
   - 不允许跳过 P0 任务直接实现 P1/P2 任务
   - 前端页面相关任务（如有）必须在后端接口之前或同步进行
   
2. MVP 完成判定
   - 所有 P0 任务完成
   - MVP 核心测试用例通过
   
3. 执行测试用例
   - 执行 MVP 核心测试场景
   - 执行回归测试
   - 主流程 E2E（优先使用 chrome MCP server）+ 全部单元测试通过视为通过标准
   
4. 汇报：
   - 实现要点
   - 测试结果
   - MVP 验证结果
   
5. 等待确认：
   a. 认可 MVP：
      - 按优先级顺序（P0 → P1 → P2）推进剩余任务
      - 每完成一个任务：
        * 更新 task.md 状态
        * 记录实现与测试结果
      - 自动开始下一个同优先级或更高优先级的任务
   b. 不认可 MVP：
      - 回到文档阶段修正
      - 重新定义 MVP 任务优先级
   c. 如遇缺依赖、潜在破坏性改动或测试无法落地，必须暂停并与我确认
```

------

## 九、阶段七：回归检查与收尾

- 检查：
  - 是否符合最初需求理解
  - 是否存在遗漏场景
- 若发现问题：
  - 补充 todo
  - 自动进入修正流程

------

## 十、文档输出结构（真实落盘）

```text
./mydoc/
├── catalog.md
└── {date}-{taskname}/
    ├── framework.md   # 需求 / 识别 / 设计 / 测试
    └── task.md        # todo / MVP / 执行状态
```

------

## 十一、成功判定标准

新功能实现被视为成功，必须满足：

- 需求被正确理解并文档化
- 已显式识别是否存在旧实现
- 功能行为与测试一致
- MVP 验证通过
- 未破坏既有系统行为
- 主流程 E2E（chrome MCP server 优先）通过，全部单元测试通过
- 全流程可复盘
