
---
description: 用于在现有项目中以工程化、科学的方法实现一个新功能
---
---
details:  支持从多种信息来源理解需求，强制识别是否存在旧实现， 遵循“文档先行 → 测试先行 → 实现 → MVP 快速验证”的流程， 并在可控、可回滚的前提下自动推进。
---

## 一、User Input

```text
`1. 加载以下提示词文档（按顺序，遵循 doc_loader.md 规则）：
   - ${old_base}
   - ${new_base}
   - ${codestyle}`
   - ${data_rule}`

2. 我将提供一个新功能需求以及需求信息来源，其信息来源可能包括：
   - 在线网站 / URL
   - 图片或截图
   - 文档（PRD / Markdown / PDF / Notion 等）
   - Figma URL 或设计稿

3. 请你严格按照本文档定义的流程，
   以科学、工程化的方式完成新功能实现任务：

   $ARGUMENTS
```

## 二、总体目标与基本原则

### 目标

- 正确理解需求，而不是猜测需求
- 避免重复实现或隐式替换旧逻辑
- 以最小风险的方式引入新能力
- 确保每一步都有文档与验证依据

### 基本原则（强制）

```
- 不跳步
- 不脑补
- 不直接实现
- 所有结论必须可复盘
```

------

## 三、阶段一：读取信息来源 & 需求理解（禁止设计与实现）

### 3.1 信息来源识别

识别我提供的需求来源类型，并采用对应的理解策略：

- **在线网站 / URL**
  - 关注用户路径、可观察行为
  - 不假设后端或隐藏规则
- **图片 / 截图**
  - 明确 UI 元素、状态、信息层级
  - 交互行为必须标注为推断
- **文档**
  - 提取明确规则、输入输出、边界条件
  - 标注歧义、不一致或可能过期内容
- **Figma**
  - 理解设计意图与交互流
  - 明确设计 ≠ 技术实现

------

### 3.2 需求理解原则（强制）

```
- 只做理解，不做设计
- 明确区分：事实 / 推断 / 假设
- 不允许隐式前提
```

------

### 3.3 输出：需求理解模块（写入 framework.md）

```markdown
## 需求理解

### 1. 需求来源
- 来源类型：
- 内容摘要：

### 2. 已确认事实（Facts）
- ...

### 3. 推断的意图（Inferred Intent）
- ...（注明依据）

### 4. 假设（Assumptions）
- ...

### 5. 澄清点 / 未决问题（最多 5 个）
- ...

### 6. 功能边界
- 明确做什么
- 明确不做什么
```

> 若存在关键澄清点，必须先与我确认，不得进入下一阶段。

------

## 四、阶段二：现有实现识别（强制阶段）

### 4.1 阶段目标

- 判断系统中是否已经存在：
  - 相同功能
  - 相似能力
  - 可复用或可演进的旧实现
- 防止：
  - 重复造轮子
  - 无意中形成“隐式替换”

------

### 4.2 执行规则（强制）

```
- 不允许假设“这是全新功能”
- 不允许直接进入设计阶段
- 必须显式给出结论
```

------

### 4.3 执行内容

在代码库中主动检查：

- 是否存在：
  - 语义相近的模块 / 类 / 函数
  - 已通过配置或内部使用的类似能力
- 若发现相关实现：
  - 分析其覆盖范围与不足
- 若未发现：
  - 明确记录“未发现相关实现”

------

### 4.4 输出：现有实现识别模块（写入 framework.md）

```markdown
## 现有实现识别

### 1. 是否存在相关实现
- 是 / 否

### 2. 已发现的相关实现（如有）
- 位置（模块 / 文件）：
- 当前能力：
- 已知限制：

### 3. 复用或演进可能性
- 可直接复用
- 可扩展演进
- 不适合复用（原因）

### 4. 结论
- 新功能应：
  - 基于现有实现演进
  - 或作为独立模块新增
```

------

## 五、阶段三：功能设计与实现规划（文档先行）

### 5.1 设计约束（继承 new_base）

- 最小侵入
- 边界清晰
- 默认可配置、可回滚
- 明确 MVP 与演进路径

------

### 5.2 输出：新功能设计模块（写入 framework.md）

```markdown
## 新功能设计

### 1. 功能目标
- 要解决的问题
- 核心价值

### 2. 设计思路
- 模块划分
- 与现有系统的交互方式

### 3. 接口与数据设计
- 对外接口
- 核心数据结构

### 4. 行为说明
- 正常流程
- 异常与边界场景

### 5. MVP 定义
- MVP 包含的能力
- 明确不包含的内容

### 6. 后续演进方向
- 可扩展点
- 潜在优化方向
```

------

## 六、阶段四：测试用例设计（先于实现）

### 6.1 测试设计原则

- 测试是功能语义的可执行表达
- 测试用于约束实现，而不是事后补充
- MVP 测试必须覆盖核心成功路径

------

### 6.2 输出：测试设计模块（写入 framework.md 或 task.md）

```markdown
## 测试设计

### 1. 核心测试场景
- Given / When / Then

### 2. 边界与异常测试
- ...

### 3. 回归关注点
- ...
```

------

## 七、阶段五：任务拆解与 MVP 规划

### 7.1 Todo List（写入 task.md）

每个任务必须包含：

- 任务目的
- 改动点
- 验收标准
- 对应测试
- 状态（TODO / DOING / DONE / BLOCKED）

------

### 7.2 MVP 验证定义（强制）

- MVP 必须：
  - 验证新功能是否可用
  - 验证未破坏既有行为
- 明确验证步骤与成功标准

------

## 八、阶段六：实现 & MVP 快速验证

### 8.1 实现规则

- 严格遵循 `new_base` 与 `codestyle`
- 不得绕过测试设计直接实现
- 不得引入未记录的新依赖或行为变化
- * 涉及到数据库操作必须严格遵守 `data_rule`

------

### 8.2 推进机制

```
1. 实现 MVP
2. 执行测试用例
3. 汇报：
   - 实现要点
   - 测试结果
4. 等待确认：
   a. 认可：
      - 按 todo 顺序推进
      - 每完成一个任务：
        * 更新 task.md 状态
        * 记录实现与测试结果
      - 自动开始下一个任务
   b. 不认可：
      - 回到文档阶段修正
```

------

## 九、阶段七：回归检查与收尾

- 检查：
  - 是否符合最初需求理解
  - 是否存在遗漏场景
- 若发现问题：
  - 补充 todo
  - 自动进入修正流程

------

## 十、文档输出结构（真实落盘）

```text
./{workspace}/mydoc/
├── catalog.md
└── {taskname}-{date}/
    ├── framework.md   # 需求 / 识别 / 设计 / 测试
    └── task.md        # todo / MVP / 执行状态
```

------

## 十一、成功判定标准

新功能实现被视为成功，必须满足：

- 需求被正确理解并文档化
- 已显式识别是否存在旧实现
- 功能行为与测试一致
- MVP 验证通过
- 未破坏既有系统行为
- 全流程可复盘