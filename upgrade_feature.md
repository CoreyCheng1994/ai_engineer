
---
description: 对“已有功能”进行迭代与演进
---
---
details:  强调先冻结当前功能语义，再明确迭代目标，
通过可控、可回滚的方式逐步演进功能行为，
避免语义漂移与隐式破坏
---

# 功能迭代 Prompt（Feature Iteration）

## 一、User Input

```text
1. 加载以下提示词文档（遵循 doc_loader.md 规则）：
   ${old_base}
   ${git_rules}
   ${codestyle}
   ${constitution}（如存在，项目级基础规则）

2. 我将提供一个“已有功能”的迭代需求，
   可能包含：
   - 新的业务诉求
   - 行为调整说明
   - 用户反馈 / Issue
   - 文档或链接

3. 请你严格按照本文档定义的流程，
   以工程化、可演进的方式推进功能迭代：

   $ARGUMENTS
````

### 前置环境检查（强制）

- 遵循 `git_rules` 中的 Git 规则
- 确认输出目录 `./mydoc/{date}-{taskname}/` 可写，不存在则创建
- 按 doc_loader 规则检查所需 prompt 是否可读取，缺失时必须暂停并告知
- 若迭代涉及数据模型/存储或迁移，需额外加载并遵循 `data_rule`

> 注意：
> 本 Prompt **不用于全新功能**，也 **不用于纯 Bugfix**。

---

## 二、总体原则（强制）

```
- 功能迭代 ≠ 新功能 ≠ Bugfix
- 不允许在未冻结当前语义前进行任何设计或实现
- 默认不引入新实现或结构性改动
- 若需要引入新实现，必须暂停并升级流程
- 所有行为变化必须显式记录
```

---

## 三、阶段一：当前功能语义冻结（Iteration Baseline）

### 目标

明确回答：

> “这个功能在『现在』到底是什么？”

---

### 执行要求

* 从代码、文档、实际行为中总结：

    * 当前对外行为
    * 已承诺的语义
    * 用户或模块依赖的关键点
* 区分：

    * **显式语义（必须保持）**
    * **偶然实现细节（不保证）**

---

### 输出（写入 framework.md）

```markdown
## 当前功能语义（Baseline）

### 1. 功能概述
- 功能目的：
- 使用场景：

### 2. 当前对外行为
- 正常行为：
- 边界行为：
- 异常行为：

### 3. 已承诺语义（Must Keep）
- ...

### 4. 非承诺行为（Implementation Detail）
- ...
```

> 若对当前语义无法达成共识，**禁止进入下一阶段**。

---

## 四、阶段二：迭代目标澄清（What is changing）

### 目标

明确这次迭代**要改变什么、不改变什么**。

---

### 执行要求

* 明确迭代类型：

    * 能力增强（Additive）
    * 行为调整（Behavioral Change）
* 明确：

    * 新增或调整的能力
    * 必须保持不变的行为

---

### 输出（写入 framework.md）

```markdown
## 迭代目标

### 1. 迭代动机
- 背景：
- 期望收益：

### 2. 本次变化点
- 新增 / 调整的能力：
- 不在本次迭代范围内的内容：

### 3. 行为变化说明
- 是否改变既有语义：是 / 否
- 若是，变化点：
```

---

## 五、阶段三：影响范围分析（Blast Radius）

### 目标

防止“改一个功能，伤一片系统”。

---

### 执行要求

分析迭代可能影响的：

* 依赖模块
* 用户路径
* 数据与配置
* 测试与文档

---

### 输出（写入 framework.md）

```markdown
## 影响范围分析

- 受影响模块：
- 潜在回归点：
- 是否需要兼容旧行为：
- 是否需要过渡策略：
```

---

## 六、阶段四：迭代策略选择（How to iterate）

### 可选策略

* 原位增强（In-place）
* 并行能力（Parallel / Config）
* 分层接口（Layered）

---

### 输出（写入 framework.md）

```markdown
## 迭代策略

### 1. 候选策略
- 策略 A：
  - 描述：
  - 风险：
- （如有）策略 B：

### 2. 选定策略
- 选择：
- 理由：
- 是否支持回滚：
```

> 若策略需要引入新实现或新抽象，**必须暂停并确认是否升级加载 ${new_base} (遵循 doc_loader.md 规则)**。

---

## 七、阶段五：验收标准前置（先于实现）

### 目标

明确“什么算改对了，什么算改坏了”。

---

### 输出（写入 framework.md）

```markdown
## 验收标准

### 1. 成功标准
- ...（必须包含：主流程 E2E（优先使用 chrome MCP server）通过，全部单元测试通过）

### 2. 不允许破坏的行为
- ...

### 3. 回归关注点
- ...
```

---

## 八、阶段六：分阶段实现与验证（MVP）

### 执行原则

* MVP 优先
* 每一步都可验证、可回滚
* 不一次性完成所有能力
* 每个阶段的退出标准：主流程 E2E（chrome MCP server 优先）+ 当前范围内所有单测通过
* 如遇缺依赖、潜在破坏性改动或测试无法落地，必须暂停并与我确认

---

### task.md 输出

```markdown
## Todo List
- [TODO] ...

## MVP 定义
- MVP 能验证的点：
- 验证方式：
- 成功标准：
```

---

## 九、阶段七：实现与自动推进

### 实现规则

* 严格遵循 `codestyle`
* 只做已规划的迭代内容
* 不夹带无关优化
* 涉及到数据库操作必须严格遵守 `data_rule`

### 推进机制

* 每完成一个 todo：

    * 更新 task.md 状态
    * 记录实现与验证结果
    * 自动开始下一个 todo
* 若发现语义风险：

    * 立即暂停并与我确认

---

## 十、阶段八：迭代收尾与复盘（轻量）

### 输出（写入 framework.md）

```markdown
## 迭代总结

- 实际变化：
- 是否符合预期：
- 是否需要后续迭代：
- 是否需要补充文档 / 测试：
```

---

## 十一、输出结构（真实落盘）

```text
./mydoc/
├── catalog.md
└── {date}-{taskname}/
    ├── framework.md   # 语义冻结 / 目标 / 策略 / 验收 / 总结
    └── task.md        # todo / MVP / 状态
```
