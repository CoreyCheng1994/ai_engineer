

---
description: 以新的技术实现一个旧功能
---
---
details:  新的技术实现
---

## User Input

1. 加载以下提示词文档（遵循 doc_loader.md 规则）：
   
   ${old_base}

   ${git_rules}

   ${codestyle}
   
   ${constitution}（如存在，项目级基础规则）
   
2. 严格按照上述文档中定义的工程流程、阶段划分与规范，
   完成以下技术实现替换任务：

   $ARGUMENTS

### 前置环境检查（强制）

- 遵循 `git_rules` 中的 Git 规则
- 确认输出目录 `./mydoc/{date}-{taskname}/` 可写，不存在则创建 当前任务的简短代号（若用户未提供，直接自动生成，不必询问）
- 按 doc_loader 规则检查所需 prompt 是否可读取，缺失时必须暂停并告知
- 若涉及数据模型/存储或迁移，需额外加载并遵循 `data_rule`

## 任务执行约束（重要）

### 一、任务性质说明

- 本任务属于 **技术实现方式替换 / 第三方依赖迁移**
- 目标是：**在保持既有行为稳定的前提下，引入新的实现**
- 默认采用 **演进式替换**，而非一次性强切

------

### 二、强制执行流程（不可跳步）

你必须严格按以下阶段执行：

1. **旧实现分析**
   - 明确旧技术实现的：
     - 使用范围
     - 关键 API / 行为
     - 隐含假设与边界条件
     - 历史问题或技术债
2. **新实现规划**
   - 分析新技术方案的能力边界
   - 给出至少一套可行的迁移方案
   - 若存在多种方案，必须：
     - 对比风险 / 成本 / 侵入性
     - 给出你的推荐与理由
3. **影响范围与测试分析**
   - 对比新旧实现行为差异
   - 明确哪些行为必须完全一致
   - 明确哪些行为允许变化（如性能、配置方式）
4. **任务拆解 & MVP 定义**
   - 拆解为可执行的 todo list
   - 定义一个最小可验证的 MVP：
     - 能证明“新实现可用”
     - 能验证“旧行为未破坏”
5. **MVP 实现**
   - 优先通过：
     - Adapter
     - Feature Flag
     - 双实现对照
     - 渐进切换
6. **自动推进后续任务**
   - 在每个 todo 完成后：
     - 更新 task.md 状态
     - 记录实现要点与测试结果
     - 自动开始下一个任务

------

### 三、禁止行为（非常重要）

- ❌ 不得在未分析旧实现前直接引入新依赖
- ❌ 不得在无测试策略的情况下移除旧实现
- ❌ 不得默认假设“新实现行为等同于旧实现”
- ❌ 不得进行无记录的大范围重构

------

### 四、代码与风格规范

- 所有代码必须严格遵循：
  - `${codestyle}`
- 若项目中存在多个 codestyle 定义：
  - 优先级以 当前目录 规则为准
- 若规范冲突：
  - 选择更严格的一条
  - 并在 framework.md 中注明原因

------

### 五、澄清与中断规则

- 当出现以下情况时，必须先与我澄清（最多 5 个问题）：
  - 新旧实现存在行为不可兼容
  - 替换会影响核心业务路径
  - 需要引入新的架构决策
- 当发现高风险或破坏性影响时：
  - 必须暂停自动推进

------

### 六、输出要求（真实落盘）

所有分析与规划必须真实写入 当前目录，文档结构遵循：

```text
./mydoc/
├── catalog.md
└── {date}-{taskname}/
    ├── framework.md   # 旧实现 / 新实现 / 测试与影响分析
    └── task.md        # todo / MVP / 执行状态
```

------

### 七、成功判定标准

本次“实现方式替换”任务被视为成功，必须满足：

- 主流程 E2E（优先使用 chrome MCP server）通过，全部单元测试通过
- 新实现通过既定测试用例
- 旧实现行为未被意外破坏
- 可通过配置或开关回退至旧实现
- 文档可完整复盘迁移过程与决策依据
