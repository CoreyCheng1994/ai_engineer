description: 所有“新实现代码”的通用工程规则基座。
  适用于新功能、技术替换、重构、实验性代码等所有引入新代码的场景。
  其目标是确保新代码安全、可控、可演进地进入既有系统。

## 一、适用范围

本规则适用于以下所有场景中**新增或重写的代码**：

- 新功能实现
- 技术方案或第三方依赖替换
- 既有模块的重构或抽象调整
- 实验性或可选能力的引入

**凡是不属于“纯阅读 / 分析”的代码变更，均受本规则约束。**

---

## 二、核心目标（不可违背）

新实现代码必须满足以下工程目标：

1. **不破坏既有行为**
2. **边界清晰、职责明确**
3. **可测试、可验证**
4. **可回滚、可替换**
5. **可逐步演进，而非一次性定型**

---

## 三、新代码引入的基本原则（强制）

### 3.1 最小侵入原则

- 新代码应：
  - 尽量以新增模块、函数、类的方式引入
  - 避免直接侵入或修改核心逻辑
- 若必须修改既有代码：
  - 修改范围必须最小化
  - 不得混杂无关重构

---

### 3.2 明确边界原则

- 每一段新代码必须清楚回答：
  - **它负责什么**
  - **它不负责什么**
- 禁止：
  - 隐式副作用
  - 跨层级访问内部实现
  - 未声明的全局影响



### 3.3 行为一致性原则

- 新代码不得隐式改变既有系统的：
  - 功能语义
  - 错误处理策略
  - 可观察行为（除非明确声明）
- 若存在行为变化：
  - 必须在文档中显式记录
  - 并给出验证与回滚方案



### 3.4 可测试性原则（强制）

- 新代码必须：
  - 前后端核心逻辑必须覆盖单元测试
  - 核心逻辑不依赖具体 I/O 或外部系统
- 禁止：
  - 将核心逻辑写死在回调、框架钩子或全局状态中
- 若代码难以测试：
  - 视为设计缺陷，必须先调整设计



### 3.5 可回滚与可替换原则

- 新实现必须满足至少一种：
  - 可通过配置关闭
  - 可通过 feature flag 切换
  - 可与旧实现并存（adapter / wrapper）
- 禁止：
  - 不可逆的一次性替换
  - 无法恢复旧行为的实现方式



## 四、演进与扩展规则

### 4.1 MVP 优先

- 新实现应优先交付：
  - 最小可验证能力（MVP）
- MVP 的目标是：
  - 验证设计合理性
  - 验证与现有系统的兼容性
- 不要求：
  - 覆盖所有边界场景
  - 一次性完成全部功能



### 4.2 为未来变化预留空间

- 新代码设计时应考虑：
  - 后续扩展点
  - 替换或废弃的可能性
- 禁止：
  - 将当前假设硬编码为不可变前提



## 五、禁止行为（非常重要）

以下行为在任何情况下都不允许：

- ❌ 在未理解上下文的情况下直接侵入核心逻辑
- ❌ 将临时方案直接当作长期方案提交
- ❌ 引入无法测试的“黑盒逻辑”
- ❌ 在无文档记录的情况下改变既有行为
- ❌ 为了“省事”牺牲边界与可维护性



## 六、与其他规则的关系

- 本规则：
  - 不替代 `codestyle`
  - 不替代任务级 prompt（如新功能实现、实现方式替换）
- 本规则：
  - 是所有“新代码相关 prompt”的默认前置约束
- 若与其他规则冲突：
  - 以 **更严格、更保守** 的规则为准
  - 并在文档中注明原因



## 七、成功判定

新实现代码被视为符合 new_base 的标准，需满足：

- 行为可预测
- 影响范围清晰
- 测试可覆盖
- 可安全回滚
- 文档可复盘
